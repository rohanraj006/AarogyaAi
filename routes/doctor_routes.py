# routes/doctor_routes.py

from fastapi import APIRouter, Body, Depends, HTTPException, status, Query, UploadFile, File
from fastapi.responses import JSONResponse, StreamingResponse
from typing import List, Dict, Any, Optional
from pydantic import ValidationError
from bson import ObjectId
import tempfile
import os
import io
from datetime import datetime, timezone
from fastapi.concurrency import run_in_threadpool
import anyio

# ReportLab Imports
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER, TA_LEFT
from reportlab.lib.units import inch

# Core Imports
from security import get_current_authenticated_user
from database import user_collection, medical_records_collection, report_contents_collection
from models.schemas import User, Name, Diagnosis, Medication, ReportPDFRequest, ReportContentRequest, DictationSaveBody

# NEW AI IMPORTS
from ai_core.chatbot_service import MedicalChatbot
from ai_core.parser_service import MedicalReportParser
from ai_core.helpers import fetch_patient_context

# Initialize Services
chatbot_service = MedicalChatbot()
parser_service = MedicalReportParser(chatbot_service)

# Whisper Model Setup
try:
    from faster_whisper import WhisperModel
    import torch
    WHISPER_MODEL_SIZE = os.getenv("WHISPER_MODEL_SIZE", "tiny")
    WHISPER_DEVICE = os.getenv("WHISPER_DEVICE", "cuda" if torch.cuda.is_available() else "cpu")
    WHISPER_COMPUTE_TYPE = os.getenv("WHISPER_COMPUTE_TYPE", "float16" if WHISPER_DEVICE == "cuda" else "int8")
    whisper_model = WhisperModel(WHISPER_MODEL_SIZE, device=WHISPER_DEVICE, compute_type=WHISPER_COMPUTE_TYPE)
except ImportError:
    whisper_model = None

router = APIRouter()

# --- HELPER DEPENDENCY ---
async def get_current_doctor(current_user: User = Depends(get_current_authenticated_user)):
    if current_user.user_type != "doctor": 
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied. Only doctors can perform this action.")
    return current_user

# --- PDF GENERATION HELPER ---
def create_report_pdf(doctor_info: dict, patient_info: dict, report_content_text: str) -> io.BytesIO:
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter, rightMargin=inch, leftMargin=inch, topMargin=inch, bottomMargin=0.75 * inch)
    styles = getSampleStyleSheet() 

    styles.add(ParagraphStyle(name='CustomNormal', fontSize=10, leading=12, alignment=TA_LEFT, spaceAfter=6))
    styles.add(ParagraphStyle(name='Heading1Center', fontSize=14, leading=16, alignment=TA_CENTER, spaceAfter=20, fontName='Helvetica-Bold'))
    styles.add(ParagraphStyle(name='Heading2Left', fontSize=12, leading=14, alignment=TA_LEFT, spaceBefore=10, spaceAfter=5, fontName='Helvetica-Bold'))
    styles.add(ParagraphStyle(name='Small', fontSize=9, leading=10, alignment=TA_LEFT, spaceAfter=4))
    styles.add(ParagraphStyle(name='FooterStyle', fontSize=9, leading=10, alignment=TA_CENTER, spaceBefore=10, textColor=styles['Normal'].textColor))

    Story = []
    
    doctor_name = f"Dr. {doctor_info.get('name', {}).get('first', '')} {doctor_info.get('name', {}).get('last', '')}".strip() or "Dr. [Doctor Name]"
    
    Story.append(Paragraph("<font size=12><b>Medical Report</b></font>", styles['Heading1Center']))
    Story.append(Paragraph(f"<font size=10><b>{doctor_name}</b>, {doctor_info.get('specialization', 'Medical Practitioner')}</font>", styles['CustomNormal']))
    Story.append(Paragraph(f"<font size=9>Email: {doctor_info.get('email', '')}</font>", styles['Small']))
    Story.append(Spacer(1, 0.2 * inch))

    patient_name = f"{patient_info.get('name', {}).get('first', '')} {patient_info.get('name', {}).get('last', '')}".strip() or "[Patient Name]"
    patient_dob = patient_info.get('date_of_birth', 'N/A')
    patient_id_display = str(patient_info.get('aarogya_id', patient_info.get('_id', 'N/A')))

    Story.append(Paragraph("<font size=10><b>Patient Information:</b></font>", styles['Heading2Left']))
    Story.append(Paragraph(f"<font size=10><b>Name:</b> {patient_name}</font>", styles['CustomNormal']))
    Story.append(Paragraph(f"<font size=10><b>Aarogya ID:</b> {patient_id_display}</font>", styles['CustomNormal']))
    Story.append(Paragraph(f"<font size=10><b>Date of Birth:</b> {patient_dob}</font>", styles['CustomNormal']))
    Story.append(Spacer(1, 0.3 * inch))

    Story.append(Paragraph("<font size=10><b>Report Details:</b></font>", styles['Heading2Left']))
    report_content_formatted = report_content_text.replace('\n', '<br/>') if report_content_text else "No report content provided."
    Story.append(Paragraph(report_content_formatted, styles['CustomNormal']))

    Story.append(Spacer(1, 0.5 * inch))
    footer_text = f"Generated by Aarogya AI on {datetime.now().strftime('%Y-%m-%d %H:%M')} | Page <page/> of <npgs/>"
    Story.append(Paragraph(footer_text, styles['FooterStyle'])) 

    doc.build(Story)
    buffer.seek(0) 
    return buffer

# --- ROUTES ---

@router.get("/api/patients/search")
async def search_for_patient(
    current_user: User = Depends(get_current_doctor),
    aarogya_id: str = Query(..., min_length=10, max_length=15)
):
    if not current_user.is_authorized:
        raise HTTPException(status_code=403, detail="Unauthorized access.")

    patient = await user_collection.find_one({"aarogya_id": aarogya_id, "user_type":"patient"})
    if not patient:
        raise HTTPException(status_code=404, detail=f"No patient found with ID: {aarogya_id}")
    
    if patient.get("name"):
        patient_name = Name(**patient["name"]).model_dump()
    else:
        patient_name = {"first": patient["email"].split('@')[0], "last": ""}
    
    return {
        "aarogya_id": patient["aarogya_id"],
        "email": patient["email"],
        "name": patient_name
    }

@router.get("/my-patients", response_model=List[User])
async def get_my_patients(current_user: User = Depends(get_current_doctor)):
    if not current_user.patient_list:
        return []

    patients_cursor = user_collection.find({
        "email": {"$in": current_user.patient_list},
        "user_type": "patient"
    })
    
    patient_list = await patients_cursor.to_list(length=None)
    validated_patients = []
    for patient in patient_list:
        if '_id' in patient: patient['_id'] = str(patient['_id'])
        validated_patients.append(User.model_validate(patient))
    
    return validated_patients

@router.post("/toggle_public", tags=["Doctor"])
async def doctor_toggle_public_status(
    current_user: User = Depends(get_current_doctor),
    is_public: bool = Body(..., embed=True)
):
    if not current_user.is_authorized:
        raise HTTPException(status_code=403, detail="Unauthorized.")

    await user_collection.update_one(
        {"email": current_user.email},
        {"$set": {"is_public": is_public}}
    )
    return {"message": f"Your public status has been set to {is_public}."}

# --- TRANSCRIPTION ---
@router.post("/patient/{patient_id}/transcribe", tags=["Doctor"])
async def transcribe_medical_report(
    patient_id: str,
    audio_file: UploadFile = File(...),
    current_user: User = Depends(get_current_doctor)
):
    if not whisper_model:
        raise HTTPException(status_code=503, detail="Voice transcription model not loaded.")

    if not audio_file.filename:
        raise HTTPException(status_code=400, detail="No audio file uploaded.")

    tmp_file_path = None
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=f"_{audio_file.filename}") as tmp_file:
            file_content = await audio_file.read()
            await anyio.to_thread.run_sync(tmp_file.write, file_content)
            tmp_file_path = tmp_file.name

        segments_generator, info = await run_in_threadpool(
             whisper_model.transcribe,
             tmp_file_path,
             beam_size=5,
             task="transcribe",
        )
        transcribed_text = "".join([segment.text for segment in segments_generator])
        
        return JSONResponse({"transcription": transcribed_text.strip()})

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Transcription error: {e}")
    finally:
        if tmp_file_path and os.path.exists(tmp_file_path):
            os.remove(tmp_file_path)

# --- REPORT GENERATION ---
@router.post("/patient/{patient_id}/generate-report-text", tags=["Doctor"])
async def generate_medical_report_text_endpoint(
    patient_id: str,
    body: Dict[str, str] = Body(...), 
    current_user: User = Depends(get_current_doctor)
):
    transcribed_text = body.get('transcribed_text')
    if not transcribed_text:
        raise HTTPException(status_code=400, detail="No transcribed text provided.")

    # Fetch patient using ID (Assuming ID corresponds to aarogya_id based on previous routes)
    patient = await user_collection.find_one({"aarogya_id": patient_id})
    if not patient:
        raise HTTPException(status_code=404, detail="Patient not found.")

    context = await fetch_patient_context(patient['email'])
    
    formatted_report_text = await chatbot_service.generate_medical_report(
        patient_data=context,
        doctor_data=current_user.model_dump(),
        transcribed_text=transcribed_text
    )

    return JSONResponse({"report_text": formatted_report_text})

# --- PDF REPORT ---
@router.post("/patient/{patient_id}/generate-pdf-report", tags=["Doctor"])
async def generate_medical_pdf_report_endpoint(
    patient_id: str,
    body: ReportPDFRequest,
    current_user: User = Depends(get_current_doctor)
):
    final_report_content_text = body.report_content_text
    if not final_report_content_text:
        raise HTTPException(status_code=400, detail="No report text provided.")

    patient = await user_collection.find_one({"aarogya_id": patient_id})
    if not patient:
        raise HTTPException(status_code=404, detail="Patient not found.")

    pdf_buffer = await run_in_threadpool(
        create_report_pdf,
        doctor_info=current_user.model_dump(),
        patient_info=patient,
        report_content_text=final_report_content_text
    )

    response = StreamingResponse(pdf_buffer, media_type="application/pdf")
    timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
    response.headers["Content-Disposition"] = f"attachment; filename=medical_report_{timestamp}.pdf"
    return response

# --- SAVE PARSED DATA ---
@router.post("/patient/{patient_id}/save-parsed-report", tags=["Doctor"])
async def save_parsed_report_data(
    patient_id: str,
    body: ReportPDFRequest,
    current_user: User = Depends(get_current_doctor)
):
    report_content_text = body.report_content_text
    if not report_content_text:
        raise HTTPException(status_code=400, detail="No content to parse.")

    patient = await user_collection.find_one({"aarogya_id": patient_id})
    if not patient:
        raise HTTPException(status_code=404, detail="Patient not found.")

    context = await fetch_patient_context(patient['email'])

    # 1. Parse Data
    extracted_data = await parser_service.parse_medical_report(
        report_text=report_content_text,
        patient_data=context,
        doctor_data=current_user.model_dump()
    )

    # 2. Save Content
    content_doc = ReportContentRequest(content_text=report_content_text).model_dump()
    insert_result = await report_contents_collection.insert_one(content_doc)
    content_id = str(insert_result.inserted_id)

    # 3. Update Record
    report_ref = {
        "report_id": content_id,
        "report_type": "AI Generated Report",
        "date": datetime.utcnow(),
        "content_id": content_id,
    }

    update_push = {"reports": report_ref}
    for key in ["diagnoses", "medications", "allergies", "consultations", "immunizations"]:
        if extracted_data.get(key):
            db_key = "current_medications" if key == "medications" else key
            
            if key == "allergies":
                update_push["allergies"] = {"$each": [a for a in extracted_data["allergies"] if isinstance(a, str) and a.strip()]}
            else:
                 update_push[db_key] = {"$each": [item for item in extracted_data[key] if isinstance(item, dict)]}

    await medical_records_collection.update_one(
        {"patient_id": patient['email']},
        {"$set": {"updated_at": datetime.utcnow()}, "$push": update_push},
        upsert=True
    )

    return JSONResponse({"message": "Saved successfully", "content_id": content_id, "extracted_data": extracted_data})